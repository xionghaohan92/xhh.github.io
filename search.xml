<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[packed数组]]></title>
    <url>%2F2019%2F11%2F22%2Fpacked%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[简介php7底层数组实现中，为了节省空间，将数组分为了哈希数组和packed数组。简单来说，pacekd数组有以下特征： key全为数字 插入顺序需按key递增 但这并不是packed数组的真正定义。packed数组在一定情况下会转化为哈希数组。什么情况下会触发转化呢？转化的判断涉及还涉及扩容相关的计算，需要从源码处确认。 数据结构在区分哈希数组和packed数组之前，我们先复习下php7数组的基本结构。 123456789101112131415161718192021struct _zend_array &#123; zend_refcounted_h gc; union &#123; struct &#123; ZEND_ENDIAN_LOHI_4( zend_uchar flags, zend_uchar nApplyCount, zend_uchar nIteratorsCount, zend_uchar consistency) &#125; v; uint32_t flags; &#125; u; uint32_t nTableMask; Bucket *arData; uint32_t nNumUsed; uint32_t nNumOfElements; uint32_t nTableSize; uint32_t nInternalPointer; zend_long nNextFreeElement; dtor_func_t pDestructor;&#125;; nTableMask:散列函数映射存储元素在arData中的下标 *arData:存储数组元素，每个元素结构统一为Bucket nNumUsed:当前数组使用的bucket数，注意nNumUsed代表的是当前使用的bucket数，是始终递增的。例如$a[1=&gt;”11”,6=&gt;”66”],此时nNumUsed为6，不为2。 nNumOfElements:数组中有效元素的数量 nTableSize:数组总容量 nInternalPointer:// nNextFreeElement:下一个自动确定的数值索引。例如对一个空数组$a，令$a[]=1,这个值则有0变为1 pDestructor:当删除或覆盖数组中某个元素时，如果提供了某函数句柄，则在删除或覆盖元素后调用某函数 12345typedef struct _Bucket &#123; zval val; //value 例如$arr[a]=1,此处即存1 zend_ulong h; //索引值 zend_string *key; //key 例如$arr[a]=1,此处即存a&#125; Bucket; 逻辑索引为了保证数组的”有序“（这里的有序是指记录插入顺序。即遍历数组的时候,遍历元素的顺序应该是和插入顺序是一致的,而不是像普通字典一样是随机的）。php7在中HashTable和bucket中间实现了一个逻辑上的索引表，保障了有序。具体来说，插入新元素时，始终在 bucket 数组的最后一个有效元素的后面插入，以此保证数组有序。 图片摘自《php7内核剖析》 头部的逻辑索引保证了php数组的顺序，但也带来了不必要的开销。数组下标从0开始的普通数组，逻辑索引并没有起到太大用处，为了存储逻辑索引，还需要消耗n个字节的内存（其中n为数组大小）。故对于这一类数组，php7取消了逻辑索引（但仍然预留了两字节，意义不明），这便是packed数组。packed数组与哈希数组除逻辑索引外，其余结构完全相同。 packed数组的判断条件packed数组的设计对顶层用户透明，但我们可从代码中确认它的详细定义。以下是插入和更新数组时的函数源码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253static zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht, zend_ulong h, zval *pData, uint32_t flag ZEND_FILE_LINE_DC)&#123; uint32_t nIndex; uint32_t idx; Bucket *p; IS_CONSISTENT(ht); HT_ASSERT(GC_REFCOUNT(ht) == 1); if (UNEXPECTED(!(ht-&gt;u.flags &amp; HASH_FLAG_INITIALIZED))) &#123; CHECK_INIT(ht, h &lt; ht-&gt;nTableSize); if (h &lt; ht-&gt;nTableSize) &#123; p = ht-&gt;arData + h; goto add_to_packed; &#125; goto add_to_hash; &#125; else if (ht-&gt;u.flags &amp; HASH_FLAG_PACKED) &#123; if (h &lt; ht-&gt;nNumUsed) &#123;//h小于当前已有的元素数量 p = ht-&gt;arData + h; if (Z_TYPE(p-&gt;val) != IS_UNDEF) &#123;//不为空 if (flag &amp; HASH_ADD) &#123; return NULL; &#125; if (ht-&gt;pDestructor) &#123; ht-&gt;pDestructor(&amp;p-&gt;val); &#125; ZVAL_COPY_VALUE(&amp;p-&gt;val, pData); if ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123; ht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + 1 : ZEND_LONG_MAX; &#125; return &amp;p-&gt;val; &#125; else &#123; /* we have to keep the order :( 否则触发转化*/ goto convert_to_hash; &#125; &#125; else if (EXPECTED(h &lt; ht-&gt;nTableSize)) &#123; p = ht-&gt;arData + h; &#125; else if ((h &gt;&gt; 1) &lt; ht-&gt;nTableSize &amp;&amp; (ht-&gt;nTableSize &gt;&gt; 1) &lt; ht-&gt;nNumOfElements) &#123;//此处判断扩容条件，判断失败则触发转化 zend_hash_packed_grow(ht); p = ht-&gt;arData + h; &#125; else &#123; goto convert_to_hash; &#125;add_to_packed:...convert_to_hash:...add_to_hash:...&#125; 触发逻辑如图所示： packed数组转哈希数组的触发逻辑 扩容需满足的条件如下：当前容量扩大两倍能包含h，并且当前数组bucket已使用一半以上。至此，我们可以回答什么情况下packed数组会转化成哈希数组。（以下新增元素的key简称为h,数组当前已用到的最大bucket下标简称为nNumUsed，数组总容量简称为size。） h大于size，且未达到扩容标准时，触发转化 h小于nNumUsed，且该bucket位上为IS_UNDEFIND时，触发转化。ps:数组初始化时，分配但未使用的bucket属性都为IS_UNDEFIND case1:12345&lt;?php$arr[1]=&gt;11;$arr[7]=&gt;77;$arr[9]=&gt;99;&gt; 最终$arr是哈希数组。因为9(h)&gt;7(nNumUsed),且不满足扩容条件,触发转化。 case2:12345&lt;?php$arr[6]=&gt;66;$arr[7]=&gt;77;$arr[1]=&gt;11;&gt; 最终$arr是哈希数组。因为1(h)&lt;7(nNumUsed),且bucket[1]此时为IS_UNDEFINED,触发转化。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奇怪的循环变量]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%A5%87%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php中循环引出的问题 问题描述有问题如下：12345678910&lt;?php$arr = [1,2,3];foreach ($arr as &amp;$v)&#123;&#125;foreach ($arr as $v)&#123; &#125;print_r($arr); 结果输出了：123456Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 2) 分析这里的v在第一次循环结束时并没有释放，循环结束后v依然指向arr的最后一个元素，而不是第一个元素。且由于是引用赋值，改变v的值是可以影响arr数组的，为之后的”bug”埋下了伏笔。换句话说，代码等价于:12345678910&lt;?php$arr = [1,2,3];foreach ($arr as &amp;$v)&#123;&#125;foreach ($arr as &amp;$v)&#123; &#125;print_r($arr); 第二次循环开始了，循环时会依次把遍历中的数组元素赋给v,注意这里v依然指向数组的最后一个元素，三次赋值的结果如下： $v&lt;-1,arr开始为[1,2,3]，赋值后arr为[1,2,1] $v&lt;-2,arr开始为[1,2,1]，赋值后arr为[1,2,2] $v&lt;-2,arr开始为[1,2,2]，赋值后arr为[1,2,2] 根本原因php中没有把循环看作一个独立的空间，在循环过程中新声明的变量就是全局变量，循环结束后变量并没有被释放。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识php-fpm]]></title>
    <url>%2F2018%2F03%2F28%2F%E5%88%9D%E8%AF%86php-fpm%2F</url>
    <content type="text"><![CDATA[一次完整的网络请求客户端发起请求时，php并不是像Golang那样实现http网络库，而是实现CGI协议，与web服务器配合实现了HTTP的处理。web服务处理HTTP请求，然后将解析结果再通过CGI协议转给底层解释器处理。 名词解释CGICGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI的好处是完全独立于任何服务器，仅仅是做为中间分子。提供接口给服务器和php，但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 FastCGIFastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。 PHP-CGIPHP 对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPMPHP 对 Web Server 提供的 FastCGI 协议的接口程序。 相关操作php-fpm在PHP 5.3.2以后的版本不支持以前的php-fpm (start|restart|stop|reload) 1234service php-fpm startservice php-fpm stopservice php-fpm restartservice php-fpm reload 基本实现FPM同时监听多个端口，每个端口对应一个worker pool，每个pool下对应多个worker 进程。但这些归属不同pool的woker进程仍然由一个master进程管理。示意图如下 什么是worker pool?123456789101112131415161718192021struct fpm_worker_pool_s &#123; struct fpm_worker_pool_s *next; /*下一个woker pool指针*/ struct fpm_worker_pool_config_s *config; /*php-fpm.conf相关*/ char *user, *home; /* for setting env USER and HOME */ enum fpm_address_domain listen_address_domain; int listening_socket; int set_uid, set_gid; /* config uid and gid */ int socket_uid, socket_gid, socket_mode; /* runtime */ struct fpm_child_s *children; int running_children; int idle_spawn_rate; int warn_max_children; struct fpm_scoreboard_s *scoreboard; /*记录worker进程运行信息的结构，记录FPM所有worker进程的统计信息*/ int log_fd; char **limit_extensions; /* for ondemand PM */ struct fpm_event_s *ondemand_event; int socket_event_set;&#125;; pool下的每个worker进程分配一个fpm_scoreboard_proc_s的结构，这些结构的地址保存在fpm_scoreboard_s-&gt;procs数组中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct fpm_scoreboard_s &#123; union &#123; atomic_t lock; char dummy[16]; &#125;;//锁状态 char pool[32];//实例名称 例如：[www] int pm; //PM运行模式 这里有三种可选择：static、ondemand、dynamic time_t start_epoch; //开始时间 int idle;//procs的空闲数 int active;//procs的使用数 int active_max; //最大procs使用数 unsigned long int requests; unsigned int max_children_reached; //到达最大进程数限制的次数 int lq; //当前listen queue的请求数(accept操作，可以过tcpi_unacked或getsocketopt获取) int lq_max;//listen queue大小 unsigned int lq_len; unsigned int nprocs; //procs总数 int free_proc; //从procs列表遍历下一个空闲对象的开始下标 struct fpm_scoreboard_proc_s *procs[]; //列表&#125;;struct fpm_scoreboard_proc_s &#123; union &#123; atomic_t lock; char dummy[16]; &#125;;//锁状态 int used; //使用标识 0=未使用 1=正在使用 time_t start_epoch; //使用开始时间 pid_t pid; //进程id unsigned long requests; //处理请求次数 enum fpm_request_stage_e request_stage; //处理请求阶段 struct timeval accepted; //accept请求时间 struct timeval duration; //脚本总执行时间 time_t accepted_epoch;//accept请求时间戳(秒) struct timeval tv; //活跃时间 char request_uri[128]; //请求路径 char query_string[512]; //请求参数 char request_method[16]; //请求方式 size_t content_length; //请求内容长度 /* used with POST only */ char script_filename[256];//脚本名称 char auth_user[32];#ifdef HAVE_TIMES struct tms cpu_accepted; struct timeval cpu_duration; struct tms last_request_cpu; struct timeval last_request_cpu_duration;#endif size_t memory;//脚本占用的内存大小&#125;; 三种进程管理方式 static : 静态模式，启动时分配固定的worker进程。 ondemand: 按需分配，当收到用户请求时fork worker进程。 dynamic: 动态模式，启动时分配固定的进程。伴随着请求数增加，在设定的浮动范围调整worker进程。master进程与worker进程的通信 fpm_scoreboard_proc_s在共享内存上，master通过这种方式获取worker的运营信息。 进程检查定时器：1234567891011121314 void fpm_event_loop(int err) /* &#123;&#123;&#123; */&#123;... /* add timers */ if (fpm_globals.heartbeat &gt; 0) &#123; fpm_pctl_heartbeat(NULL, 0, NULL); &#125; if (!err) &#123; fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL); ... &#125;... &#125; fork完worker进城后，master进程会进入fpm_event_loop，其中fpm_pctl_perform_idle_server_maintenance_heartbeat定期检查worker进程数，并根据不同策略”kill“或“fork” worker进程。 worker进程 调用fpm_request_info、php_request_startup获取请求内容及注册全局变量($_GET、$_POST、$_SERVER、$_ENV、$_FILES)； 根据请求信息调用php_fopen_primary_script访问脚本文件； 交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。-执行php_request_shutdown函数。回调register_shutdown_function注册的函数及__destruct参考资料http://blog.csdn.net/Mijar2016/article/details/53414402]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
