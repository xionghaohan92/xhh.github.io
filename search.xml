<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>奇怪的循环变量</title>
      <link href="/2018/05/09/%E5%A5%87%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F/"/>
      <url>/2018/05/09/%E5%A5%87%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>php中循环引出的问题<br><a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有问题如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $v)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">print_r($arr);</span><br></pre></td></tr></table></figure></p><p>结果输出了：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里的v在第一次循环结束时并没有释放，循环结束后v依然指向arr的最后一个元素，而不是第一个元素。且由于是引用赋值，改变v的值是可以影响arr数组的，为之后的”bug”埋下了伏笔。换句话说，代码等价于:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">print_r($arr);</span><br></pre></td></tr></table></figure></p><p>第二次循环开始了，循环时会依次把遍历中的数组元素赋给v,注意这里v依然指向数组的最后一个元素，三次赋值的结果如下：</p><ul><li>$v&lt;-1,arr开始为[1,2,3]，赋值后arr为[1,2,1]</li><li>$v&lt;-2,arr开始为[1,2,1]，赋值后arr为[1,2,2]</li><li>$v&lt;-2,arr开始为[1,2,2]，赋值后arr为[1,2,2]</li></ul><h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>php中没有把循环看作一个独立的空间，在循环过程中新声明的变量就是全局变量，循环结束后变量并没有被释放。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识php-fpm</title>
      <link href="/2018/03/28/%E5%88%9D%E8%AF%86php-fpm/"/>
      <url>/2018/03/28/%E5%88%9D%E8%AF%86php-fpm/</url>
      
        <content type="html"><![CDATA[<h2 id="一次完整的网络请求"><a href="#一次完整的网络请求" class="headerlink" title="一次完整的网络请求"></a>一次完整的网络请求</h2><p>客户端发起请求时，php并不是像Golang那样实现http网络库，而是实现CGI协议，与web服务器配合实现了HTTP的处理。web服务处理HTTP请求，然后将解析结果再通过CGI协议转给底层解释器处理。<br><a id="more"></a></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI的好处是完全独立于任何服务器，仅仅是做为中间分子。提供接口给服务器和php，但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。</p><h3 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h3><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。</p><h3 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h3><p>PHP 对 Web Server 提供的 CGI 协议的接口程序。</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>PHP 对 Web Server 提供的 FastCGI 协议的接口程序。</p><h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>php-fpm在PHP 5.3.2以后的版本不支持以前的php-fpm (start|restart|stop|reload)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service php-fpm start</span><br><span class="line">service php-fpm stop</span><br><span class="line">service php-fpm restart</span><br><span class="line">service php-fpm reload</span><br></pre></td></tr></table></figure><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>FPM同时监听多个端口，每个端口对应一个worker pool，每个pool下对应多个worker 进程。<strong>但这些归属不同pool的woker进程仍然由一个master进程管理</strong>。示意图如下</p><h3 id="什么是worker-pool"><a href="#什么是worker-pool" class="headerlink" title="什么是worker pool?"></a>什么是worker pool?</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> *<span class="title">next</span>;</span>                     <span class="comment">/*下一个woker pool指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_config_s</span> *<span class="title">config</span>;</span>            <span class="comment">/*php-fpm.conf相关*/</span></span><br><span class="line">    <span class="keyword">char</span> *user, *home;                                  <span class="comment">/* for setting env USER and HOME */</span></span><br><span class="line">    <span class="keyword">enum</span> fpm_address_domain listen_address_domain;</span><br><span class="line">    <span class="keyword">int</span> listening_socket;</span><br><span class="line">    <span class="keyword">int</span> set_uid, set_gid;                               <span class="comment">/* config uid and gid */</span></span><br><span class="line">    <span class="keyword">int</span> socket_uid, socket_gid, socket_mode;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* runtime */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_child_s</span> *<span class="title">children</span>;</span>                     </span><br><span class="line">    <span class="keyword">int</span> running_children;</span><br><span class="line">    <span class="keyword">int</span> idle_spawn_rate;</span><br><span class="line">    <span class="keyword">int</span> warn_max_children;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_s</span> *<span class="title">scoreboard</span>;</span>                <span class="comment">/*记录worker进程运行信息的结构，记录FPM所有worker进程的统计信息*/</span></span><br><span class="line">    <span class="keyword">int</span> log_fd;</span><br><span class="line">    <span class="keyword">char</span> **limit_extensions;</span><br><span class="line">    <span class="comment">/* for ondemand PM */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_event_s</span> *<span class="title">ondemand_event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> socket_event_set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pool下的每个worker进程分配一个fpm_scoreboard_proc_s的结构，这些结构的地址保存在fpm_scoreboard_s-&gt;procs数组中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">atomic_t</span> lock;</span><br><span class="line">        <span class="keyword">char</span> dummy[<span class="number">16</span>];</span><br><span class="line">    &#125;;<span class="comment">//锁状态</span></span><br><span class="line">    <span class="keyword">char</span> pool[<span class="number">32</span>];<span class="comment">//实例名称 例如：[www]</span></span><br><span class="line">    <span class="keyword">int</span> pm; <span class="comment">//PM运行模式 这里有三种可选择：static、ondemand、dynamic</span></span><br><span class="line">    <span class="keyword">time_t</span> start_epoch; <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">int</span> idle;<span class="comment">//procs的空闲数</span></span><br><span class="line">    <span class="keyword">int</span> active;<span class="comment">//procs的使用数</span></span><br><span class="line">    <span class="keyword">int</span> active_max; <span class="comment">//最大procs使用数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> requests;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_children_reached; <span class="comment">//到达最大进程数限制的次数</span></span><br><span class="line">    <span class="keyword">int</span> lq; <span class="comment">//当前listen queue的请求数(accept操作，可以过tcpi_unacked或getsocketopt获取)</span></span><br><span class="line">    <span class="keyword">int</span> lq_max;<span class="comment">//listen queue大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lq_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nprocs; <span class="comment">//procs总数</span></span><br><span class="line">    <span class="keyword">int</span> free_proc; <span class="comment">//从procs列表遍历下一个空闲对象的开始下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_proc_s</span> *<span class="title">procs</span>[];</span> <span class="comment">//列表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_proc_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">atomic_t</span> lock;</span><br><span class="line">        <span class="keyword">char</span> dummy[<span class="number">16</span>];</span><br><span class="line">    &#125;;<span class="comment">//锁状态</span></span><br><span class="line">    <span class="keyword">int</span> used; <span class="comment">//使用标识 0=未使用 1=正在使用</span></span><br><span class="line">    <span class="keyword">time_t</span> start_epoch; <span class="comment">//使用开始时间</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">//进程id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> requests; <span class="comment">//处理请求次数</span></span><br><span class="line">    <span class="keyword">enum</span> fpm_request_stage_e request_stage; <span class="comment">//处理请求阶段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">accepted</span>;</span> <span class="comment">//accept请求时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">duration</span>;</span> <span class="comment">//脚本总执行时间</span></span><br><span class="line">    <span class="keyword">time_t</span> accepted_epoch;<span class="comment">//accept请求时间戳(秒)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span> <span class="comment">//活跃时间</span></span><br><span class="line">    <span class="keyword">char</span> request_uri[<span class="number">128</span>]; <span class="comment">//请求路径</span></span><br><span class="line">    <span class="keyword">char</span> query_string[<span class="number">512</span>]; <span class="comment">//请求参数</span></span><br><span class="line">    <span class="keyword">char</span> request_method[<span class="number">16</span>]; <span class="comment">//请求方式</span></span><br><span class="line">    <span class="keyword">size_t</span> content_length; <span class="comment">//请求内容长度 /* used with POST only */</span></span><br><span class="line">    <span class="keyword">char</span> script_filename[<span class="number">256</span>];<span class="comment">//脚本名称</span></span><br><span class="line">    <span class="keyword">char</span> auth_user[<span class="number">32</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_TIMES</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">cpu_accepted</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">cpu_duration</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">last_request_cpu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_request_cpu_duration</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> memory;<span class="comment">//脚本占用的内存大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="三种进程管理方式"><a href="#三种进程管理方式" class="headerlink" title="三种进程管理方式"></a>三种进程管理方式</h3><ul><li>static : 静态模式，启动时分配固定的worker进程。 </li><li>ondemand: 按需分配，当收到用户请求时fork worker进程。 </li><li>dynamic: 动态模式，启动时分配固定的进程。伴随着请求数增加，在设定的浮动范围调整worker进程。<h3 id="master进程与worker进程的通信"><a href="#master进程与worker进程的通信" class="headerlink" title="master进程与worker进程的通信"></a>master进程与worker进程的通信</h3></li><li>fpm_scoreboard_proc_s在共享内存上，master通过这种方式获取worker的运营信息。</li><li>进程检查定时器：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fpm_event_loop</span><span class="params">(<span class="keyword">int</span> err)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* add timers */</span></span><br><span class="line">    <span class="keyword">if</span> (fpm_globals.heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fpm_pctl_heartbeat(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>fork完worker进城后，master进程会进入fpm_event_loop，其中fpm_pctl_perform_idle_server_maintenance_heartbeat定期检查worker进程数，并根据不同策略”kill“或“fork” worker进程。</p><h3 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h3><ul><li>调用fpm_request_info、php_request_startup获取请求内容及注册全局变量($_GET、$_POST、$_SERVER、$_ENV、$_FILES)；</li><li>根据请求信息调用php_fopen_primary_script访问脚本文件；</li><li>交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。<br>-执行php_request_shutdown函数。回调register_shutdown_function注册的函数及__destruct<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><a href="http://blog.csdn.net/Mijar2016/article/details/53414402" target="_blank" rel="noopener">http://blog.csdn.net/Mijar2016/article/details/53414402</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
