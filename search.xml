<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>packed数组</title>
      <link href="/2019/11/22/packed%E6%95%B0%E7%BB%84/"/>
      <url>/2019/11/22/packed%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>php7底层数组实现中，为了节省空间，将数组分为了哈希数组和packed数组。简单来说，pacekd数组有以下特征：<a id="more"></a></p><ul><li>key全为数字</li><li>插入顺序需按key递增</li></ul><p>但这并不是packed数组的真正定义。packed数组在一定情况下会转化为哈希数组。<strong>什么情况下会触发转化呢？</strong>转化的判断涉及还涉及扩容相关的计算，需要从源码处确认。</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>在区分哈希数组和packed数组之前，我们先复习下php7数组的基本结构。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">zend_refcounted_h gc;</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">ZEND_ENDIAN_LOHI_4(</span><br><span class="line">zend_uchar    flags,</span><br><span class="line">zend_uchar    nApplyCount,</span><br><span class="line">zend_uchar    nIteratorsCount,</span><br><span class="line">zend_uchar    consistency)</span><br><span class="line">&#125; v;</span><br><span class="line"><span class="keyword">uint32_t</span> flags;</span><br><span class="line">&#125; u;</span><br><span class="line"><span class="keyword">uint32_t</span>          nTableMask;</span><br><span class="line">Bucket           *arData;</span><br><span class="line"><span class="keyword">uint32_t</span>          nNumUsed;</span><br><span class="line"><span class="keyword">uint32_t</span>          nNumOfElements;</span><br><span class="line"><span class="keyword">uint32_t</span>          nTableSize;</span><br><span class="line"><span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">zend_long         nNextFreeElement;</span><br><span class="line"><span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>nTableMask:散列函数映射存储元素在arData中的下标</li><li>*arData:存储数组元素，每个元素结构统一为Bucket</li><li>nNumUsed:当前数组使用的bucket数，注意nNumUsed代表的是当前使用的bucket数，是始终递增的。例如$a[1=&gt;”11”,6=&gt;”66”],此时nNumUsed为6，不为2。</li><li>nNumOfElements:数组中有效元素的数量</li><li>nTableSize:数组总容量</li><li>nInternalPointer://</li><li>nNextFreeElement:下一个自动确定的数值索引。例如对一个空数组$a，令$a[]=1,这个值则有0变为1</li><li>pDestructor:当删除或覆盖数组中某个元素时，如果提供了某函数句柄，则在删除或覆盖元素后调用某函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">zval              val;              <span class="comment">//value 例如$arr[a]=1,此处即存1</span></span><br><span class="line">zend_ulong        h;                <span class="comment">//索引值</span></span><br><span class="line">zend_string      *key;              <span class="comment">//key 例如$arr[a]=1,此处即存a</span></span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure><h2 id="逻辑索引"><a href="#逻辑索引" class="headerlink" title="逻辑索引"></a>逻辑索引</h2><p>为了保证数组的”有序“（这里的有序是指记录插入顺序。即遍历数组的时候,遍历元素的顺序应该是和插入顺序是一致的,而不是像普通字典一样是随机的）。php7在中HashTable和bucket中间实现了一个逻辑上的索引表，保障了有序。具体来说，插入新元素时，始终在 bucket 数组的最后一个有效元素的后面插入，以此保证数组有序。<br><img src="http://pimwvecu3.bkt.clouddn.com/image2018-3-11%2012_28_44.png" alt=""></p><center>图片摘自《php7内核剖析》</center><p>头部的逻辑索引保证了php数组的顺序，但也带来了不必要的开销。数组下标从0开始的普通数组，逻辑索引并没有起到太大用处，为了存储逻辑索引，还需要消耗n个字节的内存（其中n为数组大小）。故对于这一类数组，php7取消了逻辑索引（但仍然预留了两字节，意义不明），这便是packed数组。packed数组与哈希数组除逻辑索引外，其余结构完全相同。</p><h2 id="packed数组的判断条件"><a href="#packed数组的判断条件" class="headerlink" title="packed数组的判断条件"></a>packed数组的判断条件</h2><p>packed数组的设计对顶层用户透明，但我们可从代码中确认它的详细定义。以下是插入和更新数组时的函数源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> zend_always_inline zval *_zend_hash_index_add_or_update_i(HashTable *ht, zend_ulong h, zval *pData, <span class="keyword">uint32_t</span> flag ZEND_FILE_LINE_DC)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">uint32_t</span> nIndex;</span><br><span class="line"><span class="keyword">uint32_t</span> idx;</span><br><span class="line">Bucket *p;</span><br><span class="line"></span><br><span class="line">IS_CONSISTENT(ht);</span><br><span class="line">HT_ASSERT(GC_REFCOUNT(ht) == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (UNEXPECTED(!(ht-&gt;u.flags &amp; HASH_FLAG_INITIALIZED))) &#123;</span><br><span class="line">CHECK_INIT(ht, h &lt; ht-&gt;nTableSize);</span><br><span class="line"><span class="keyword">if</span> (h &lt; ht-&gt;nTableSize) &#123;</span><br><span class="line">p = ht-&gt;arData + h;</span><br><span class="line"><span class="keyword">goto</span> add_to_packed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">goto</span> add_to_hash;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ht-&gt;u.flags &amp; HASH_FLAG_PACKED) &#123;</span><br><span class="line"><span class="keyword">if</span> (h &lt; ht-&gt;nNumUsed) &#123;<span class="comment">//h小于当前已有的元素数量</span></span><br><span class="line">p = ht-&gt;arData + h;</span><br><span class="line"><span class="keyword">if</span> (Z_TYPE(p-&gt;val) != IS_UNDEF) &#123;<span class="comment">//不为空</span></span><br><span class="line"><span class="keyword">if</span> (flag &amp; HASH_ADD) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ht-&gt;pDestructor) &#123;</span><br><span class="line">ht-&gt;pDestructor(&amp;p-&gt;val);</span><br><span class="line">&#125;</span><br><span class="line">ZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class="line"><span class="keyword">if</span> ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123;</span><br><span class="line">ht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + <span class="number">1</span> : ZEND_LONG_MAX;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;p-&gt;val;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">/* we have to keep the order :( 否则触发转化*/</span></span><br><span class="line"><span class="keyword">goto</span> convert_to_hash;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXPECTED(h &lt; ht-&gt;nTableSize)) &#123;</span><br><span class="line">p = ht-&gt;arData + h;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((h &gt;&gt; <span class="number">1</span>) &lt; ht-&gt;nTableSize &amp;&amp;</span><br><span class="line">           (ht-&gt;nTableSize &gt;&gt; <span class="number">1</span>) &lt; ht-&gt;nNumOfElements) &#123;<span class="comment">//此处判断扩容条件，判断失败则触发转化</span></span><br><span class="line">zend_hash_packed_grow(ht);</span><br><span class="line">p = ht-&gt;arData + h;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">goto</span> convert_to_hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add_to_packed:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">convert_to_hash:</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">add_to_hash:</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>触发逻辑如图所示：<br><img src="http://pimwvecu3.bkt.clouddn.com/%E6%95%B0%E7%BB%84%E7%9A%84%E6%8F%92%E5%85%A5%E6%9B%B4%E6%96%B0%E8%A7%A6%E5%8F%91packed%E8%BD%AC%E5%93%88%E5%B8%8C.jpg" alt=""></p><center>packed数组转哈希数组的触发逻辑</center><p>扩容需满足的条件如下：当前容量扩大两倍能包含h，并且当前数组bucket已使用一半以上。<br>至此，我们可以回答什么情况下packed数组会转化成哈希数组。（以下新增元素的key简称为h,数组当前已用到的最大bucket下标简称为nNumUsed，数组总容量简称为size。）</p><ul><li>h大于size，且未达到扩容标准时，触发转化</li><li>h小于nNumUsed，且该bucket位上为IS_UNDEFIND时，触发转化。ps:数组初始化时，分配但未使用的bucket属性都为IS_UNDEFIND</li></ul><p>case1:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr[<span class="number">1</span>]=&gt;<span class="number">11</span>;</span><br><span class="line">$arr[<span class="number">7</span>]=&gt;<span class="number">77</span>;</span><br><span class="line">$arr[<span class="number">9</span>]=&gt;<span class="number">99</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>最终$arr是哈希数组。因为9(h)&gt;7(nNumUsed),且不满足扩容条件,触发转化。</p><p>case2:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr[<span class="number">6</span>]=&gt;<span class="number">66</span>;</span><br><span class="line">$arr[<span class="number">7</span>]=&gt;<span class="number">77</span>;</span><br><span class="line">$arr[<span class="number">1</span>]=&gt;<span class="number">11</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p><p>最终$arr是哈希数组。因为1(h)&lt;7(nNumUsed),且bucket[1]此时为IS_UNDEFINED,触发转化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《php7内核剖析》</li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>sdshdr5用在何处？</title>
      <link href="/2018/12/18/sdshdr5%E7%94%A8%E5%9C%A8%E4%BD%95%E5%A4%84/"/>
      <url>/2018/12/18/sdshdr5%E7%94%A8%E5%9C%A8%E4%BD%95%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在redis5中，执行以下命令，key和value最终是用哪种sds存放的？</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="built_in">set</span> a ttt</span><br></pre></td></tr></table></figure><p>#sds基础回顾</p><p>从redis3.2开始，sds就有了5种类型，5种类型分别存放不同大小的字符串。在创建字符串时，sds会根据字符串的长度选择不同的类型。最终由sdsnewlen函数创建字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;<span class="comment">//为空时强制用sdshdr8</span></span><br><span class="line">    <span class="keyword">int</span> hdrlen = sdsHdrSize(type);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fp; <span class="comment">/* flags pointer. */</span></span><br><span class="line"></span><br><span class="line">    sh = s_malloc(hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (init==SDS_NOINIT)</span><br><span class="line">        init = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!init)</span><br><span class="line">        <span class="built_in">memset</span>(sh, <span class="number">0</span>, hdrlen+initlen+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (sh == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    s = (<span class="keyword">char</span>*)sh+hdrlen;</span><br><span class="line">    fp = ((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)s)<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_16: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_32: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_64: &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了创建空字符串时会强转为SDS_TYPE_8外，没有什么其它特别之处了。</p><p>#gdb结果</p><p>问题中的key和value都是长度短于32的字符串，似乎应该都用sdshdr5来存。但gdb打印后发现，key确实是用sdshdr5存储的，但value却是用sdshdr8存储的。<br>在getCommand函数处打断点，打印c-db-&gt;dict中的相关内容：</p><p><img src="https://raw.githubusercontent.com/xionghaohan92/ImageBed/master/DingTalk20181217192313.png" alt=""></p><p>分别打印key和val的值，其中key是sds，val是robj。结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p(sds)0x7f09d2009830</span><br><span class="line"><span class="variable">$117</span> = 0x7f09d2009830 <span class="string">"\ba"</span></span><br><span class="line">(gdb) p *(robj*)0x7f09d2029830</span><br><span class="line"><span class="variable">$118</span> = &#123;<span class="built_in">type</span> = 0, encoding = 8,lru = 1536715, refcount = 1, ptr = 0x7f09d2029843&#125;</span><br><span class="line">(gdb) p(sds)0x7f09d2029842</span><br><span class="line"><span class="variable">$119</span> = 0x7f09d2029842 <span class="string">"\001ttt"</span></span><br></pre></td></tr></table></figure><ul><li>ttt前的\001，代表flags是00000001(二进制)，低三位表类型，意味着存ttt所用的类型为SDS_TYPE_8</li><li>a前的\b，代表flags是00001000（二进制），低三位表类型，意味着存a所用类型为SDS_TYPE_5</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br></pre></td></tr></table></figure><h1 id="set命令流程"><a href="#set命令流程" class="headerlink" title="set命令流程"></a>set命令流程</h1><p>光看sdsnewlen无法解释问题，执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="built_in">set</span> a ttt</span><br></pre></td></tr></table></figure><p>入口函数是setcommand，我们从setcommand命令入口看起：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    c-&gt;argv[<span class="number">2</span>] = tryObjectEncoding(c-&gt;argv[<span class="number">2</span>]);</span><br><span class="line">    setGenericCommand(c,flags,c-&gt;argv[<span class="number">1</span>],c-&gt;argv[<span class="number">2</span>],expire,unit,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终调setGenericCommand，c-&gt;argv[1],c-&gt;argv[2]是两个robj,存放着key和value,打印结果如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(gdb) p (sds)((*c-&gt;argv[1])-&gt;ptr-1)</span><br><span class="line"><span class="variable">$125</span> = 0x7f09d2029aca <span class="string">"\001a"</span></span><br><span class="line">(gdb) p (sds)((*c-&gt;argv[2])-&gt;ptr-1)</span><br><span class="line"><span class="variable">$126</span> = 0x7f09d202988a <span class="string">"\001ttt"</span></span><br></pre></td></tr></table></figure><p>可以看到，两个robj底层的sds_type都是sdshdr8。为什么是两个sdshdr8呢？argv应该是在命令解析的时候生成的，继续跟源码。命令解析的源头在readQueryFromClient,从readQueryFromClient一直往下跟，调用链如下：</p><p><img src="https://raw.githubusercontent.com/xionghaohan92/ImageBed/master/1.png" alt=""></p><p>最终走到了createStringObject：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)<span class="comment">//OBJ_ENCODING_EMBSTR_SIZE_LIMIT = 44</span></span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>redis在解析参数时，根据参数长度选不同的结构。有意思的是，参数长度小于44时，走createEmbeddedStringObject分支,但createEmbeddedStringObject中又强制用sdshdr8来存字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createEmbeddedStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(robj)+<span class="keyword">sizeof</span>(struct sdshdr8)+len+<span class="number">1</span>);<span class="comment">//指定sdshdr8</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当参数长度大于44时，走一般流程。此时创建的字符串长度既然大于44，更大于32了，自然也不可能用sdshdr5。换而言之，<strong>从clientBuffer中解析出的命令参数，redis统一用大于sdshdr5的结构存，这跟之前gdb的现象是一致的</strong>。<br>那什么时候key变成由sdshdr5存储了呢？回过头继续跟setGenericCommand，调用链如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setGenericCommand--&gt;setKey--&gt;dbAdd</span><br></pre></td></tr></table></figure><p>在dbAdd函数中，可以看到，redis对待存入的key做了一次复制，<strong>正是这次复制将key由之前的sdshdr8转成了sdshdr5</strong>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dbAdd</span><span class="params">(redisDb *db, robj *key, robj *val)</span> </span>&#123;</span><br><span class="line">    sds copy = sdsdup(key-&gt;ptr);</span><br><span class="line">    <span class="keyword">int</span> retval = dictAdd(db-&gt;dict, copy, val);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sdsdup复制只看字符串内容，根据字符串内容创建新的sds,由于key-&gt;ptr指向的字符互串是”a”,故copy这个robj底层是个sdshdr5。最终调用dictAdd时，键的robj底层是sdshdr5,而值的robj底层是sdshdr8。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>最终可以确认，长度小于32的键值对，键的底层是sdshdr5,而值的robj底层是sdshdr8。</p><ul><li><p>Q1:为什么redis这么设计？</p><p>个人猜想是键不更新而值会更新，故键用尽可能小的结构存，而值更新会引起扩容，索性直接用大些的结构存。</p></li><li><p>为什么从解析参数时，redis又抛弃了小的sdshdr5？</p><p>个人猜想是为了编码方便。不同命令的参数个数都不相同，一开始分不清哪个位置是key哪个位置是value，索性统一处理，在具体场景下，再单独优化。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> REDIS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>奇怪的循环变量</title>
      <link href="/2018/05/09/%E5%A5%87%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F/"/>
      <url>/2018/05/09/%E5%A5%87%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<p>php中循环引出的问题<br><a id="more"></a></p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>有问题如下：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> $v)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">print_r($arr);</span><br></pre></td></tr></table></figure></p><p>结果输出了：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span></span><br><span class="line">(</span><br><span class="line">    [<span class="number">0</span>] =&gt; <span class="number">1</span></span><br><span class="line">    [<span class="number">1</span>] =&gt; <span class="number">2</span></span><br><span class="line">    [<span class="number">2</span>] =&gt; <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这里的v在第一次循环结束时并没有释放，循环结束后v依然指向arr的最后一个元素，而不是第一个元素。且由于是引用赋值，改变v的值是可以影响arr数组的，为之后的”bug”埋下了伏笔。换句话说，代码等价于:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">foreach</span> ($arr <span class="keyword">as</span> &amp;$v)</span><br><span class="line">&#123;</span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line">print_r($arr);</span><br></pre></td></tr></table></figure></p><p>第二次循环开始了，循环时会依次把遍历中的数组元素赋给v,注意这里v依然指向数组的最后一个元素，三次赋值的结果如下：</p><ul><li>$v&lt;-1,arr开始为[1,2,3]，赋值后arr为[1,2,1]</li><li>$v&lt;-2,arr开始为[1,2,1]，赋值后arr为[1,2,2]</li><li>$v&lt;-2,arr开始为[1,2,2]，赋值后arr为[1,2,2]</li></ul><h2 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h2><p>php中没有把循环看作一个独立的空间，在循环过程中新声明的变量就是全局变量，循环结束后变量并没有被释放。</p>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>初识php-fpm</title>
      <link href="/2018/03/28/%E5%88%9D%E8%AF%86php-fpm/"/>
      <url>/2018/03/28/%E5%88%9D%E8%AF%86php-fpm/</url>
      
        <content type="html"><![CDATA[<h2 id="一次完整的网络请求"><a href="#一次完整的网络请求" class="headerlink" title="一次完整的网络请求"></a>一次完整的网络请求</h2><p>客户端发起请求时，php并不是像Golang那样实现http网络库，而是实现CGI协议，与web服务器配合实现了HTTP的处理。web服务处理HTTP请求，然后将解析结果再通过CGI协议转给底层解释器处理。<br><a id="more"></a></p><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><h3 id="CGI"><a href="#CGI" class="headerlink" title="CGI"></a>CGI</h3><p>CGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI的好处是完全独立于任何服务器，仅仅是做为中间分子。提供接口给服务器和php，但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。</p><h3 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h3><p>FastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。</p><h3 id="PHP-CGI"><a href="#PHP-CGI" class="headerlink" title="PHP-CGI"></a>PHP-CGI</h3><p>PHP 对 Web Server 提供的 CGI 协议的接口程序。</p><h3 id="PHP-FPM"><a href="#PHP-FPM" class="headerlink" title="PHP-FPM"></a>PHP-FPM</h3><p>PHP 对 Web Server 提供的 FastCGI 协议的接口程序。</p><h2 id="相关操作"><a href="#相关操作" class="headerlink" title="相关操作"></a>相关操作</h2><p>php-fpm在PHP 5.3.2以后的版本不支持以前的php-fpm (start|restart|stop|reload)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service php-fpm start</span><br><span class="line">service php-fpm stop</span><br><span class="line">service php-fpm restart</span><br><span class="line">service php-fpm reload</span><br></pre></td></tr></table></figure><h2 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h2><p>FPM同时监听多个端口，每个端口对应一个worker pool，每个pool下对应多个worker 进程。<strong>但这些归属不同pool的woker进程仍然由一个master进程管理</strong>。示意图如下</p><h3 id="什么是worker-pool"><a href="#什么是worker-pool" class="headerlink" title="什么是worker pool?"></a>什么是worker pool?</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_s</span> *<span class="title">next</span>;</span>                     <span class="comment">/*下一个woker pool指针*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_worker_pool_config_s</span> *<span class="title">config</span>;</span>            <span class="comment">/*php-fpm.conf相关*/</span></span><br><span class="line">    <span class="keyword">char</span> *user, *home;                                  <span class="comment">/* for setting env USER and HOME */</span></span><br><span class="line">    <span class="keyword">enum</span> fpm_address_domain listen_address_domain;</span><br><span class="line">    <span class="keyword">int</span> listening_socket;</span><br><span class="line">    <span class="keyword">int</span> set_uid, set_gid;                               <span class="comment">/* config uid and gid */</span></span><br><span class="line">    <span class="keyword">int</span> socket_uid, socket_gid, socket_mode;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* runtime */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_child_s</span> *<span class="title">children</span>;</span>                     </span><br><span class="line">    <span class="keyword">int</span> running_children;</span><br><span class="line">    <span class="keyword">int</span> idle_spawn_rate;</span><br><span class="line">    <span class="keyword">int</span> warn_max_children;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_s</span> *<span class="title">scoreboard</span>;</span>                <span class="comment">/*记录worker进程运行信息的结构，记录FPM所有worker进程的统计信息*/</span></span><br><span class="line">    <span class="keyword">int</span> log_fd;</span><br><span class="line">    <span class="keyword">char</span> **limit_extensions;</span><br><span class="line">    <span class="comment">/* for ondemand PM */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_event_s</span> *<span class="title">ondemand_event</span>;</span></span><br><span class="line">    <span class="keyword">int</span> socket_event_set;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>pool下的每个worker进程分配一个fpm_scoreboard_proc_s的结构，这些结构的地址保存在fpm_scoreboard_s-&gt;procs数组中。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">atomic_t</span> lock;</span><br><span class="line">        <span class="keyword">char</span> dummy[<span class="number">16</span>];</span><br><span class="line">    &#125;;<span class="comment">//锁状态</span></span><br><span class="line">    <span class="keyword">char</span> pool[<span class="number">32</span>];<span class="comment">//实例名称 例如：[www]</span></span><br><span class="line">    <span class="keyword">int</span> pm; <span class="comment">//PM运行模式 这里有三种可选择：static、ondemand、dynamic</span></span><br><span class="line">    <span class="keyword">time_t</span> start_epoch; <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">int</span> idle;<span class="comment">//procs的空闲数</span></span><br><span class="line">    <span class="keyword">int</span> active;<span class="comment">//procs的使用数</span></span><br><span class="line">    <span class="keyword">int</span> active_max; <span class="comment">//最大procs使用数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> requests;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_children_reached; <span class="comment">//到达最大进程数限制的次数</span></span><br><span class="line">    <span class="keyword">int</span> lq; <span class="comment">//当前listen queue的请求数(accept操作，可以过tcpi_unacked或getsocketopt获取)</span></span><br><span class="line">    <span class="keyword">int</span> lq_max;<span class="comment">//listen queue大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lq_len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nprocs; <span class="comment">//procs总数</span></span><br><span class="line">    <span class="keyword">int</span> free_proc; <span class="comment">//从procs列表遍历下一个空闲对象的开始下标</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_proc_s</span> *<span class="title">procs</span>[];</span> <span class="comment">//列表</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fpm_scoreboard_proc_s</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">atomic_t</span> lock;</span><br><span class="line">        <span class="keyword">char</span> dummy[<span class="number">16</span>];</span><br><span class="line">    &#125;;<span class="comment">//锁状态</span></span><br><span class="line">    <span class="keyword">int</span> used; <span class="comment">//使用标识 0=未使用 1=正在使用</span></span><br><span class="line">    <span class="keyword">time_t</span> start_epoch; <span class="comment">//使用开始时间</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid; <span class="comment">//进程id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> requests; <span class="comment">//处理请求次数</span></span><br><span class="line">    <span class="keyword">enum</span> fpm_request_stage_e request_stage; <span class="comment">//处理请求阶段</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">accepted</span>;</span> <span class="comment">//accept请求时间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">duration</span>;</span> <span class="comment">//脚本总执行时间</span></span><br><span class="line">    <span class="keyword">time_t</span> accepted_epoch;<span class="comment">//accept请求时间戳(秒)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span> <span class="comment">//活跃时间</span></span><br><span class="line">    <span class="keyword">char</span> request_uri[<span class="number">128</span>]; <span class="comment">//请求路径</span></span><br><span class="line">    <span class="keyword">char</span> query_string[<span class="number">512</span>]; <span class="comment">//请求参数</span></span><br><span class="line">    <span class="keyword">char</span> request_method[<span class="number">16</span>]; <span class="comment">//请求方式</span></span><br><span class="line">    <span class="keyword">size_t</span> content_length; <span class="comment">//请求内容长度 /* used with POST only */</span></span><br><span class="line">    <span class="keyword">char</span> script_filename[<span class="number">256</span>];<span class="comment">//脚本名称</span></span><br><span class="line">    <span class="keyword">char</span> auth_user[<span class="number">32</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_TIMES</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">cpu_accepted</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">cpu_duration</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tms</span> <span class="title">last_request_cpu</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">last_request_cpu_duration</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">size_t</span> memory;<span class="comment">//脚本占用的内存大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="三种进程管理方式"><a href="#三种进程管理方式" class="headerlink" title="三种进程管理方式"></a>三种进程管理方式</h3><ul><li>static : 静态模式，启动时分配固定的worker进程。 </li><li>ondemand: 按需分配，当收到用户请求时fork worker进程。 </li><li>dynamic: 动态模式，启动时分配固定的进程。伴随着请求数增加，在设定的浮动范围调整worker进程。<h3 id="master进程与worker进程的通信"><a href="#master进程与worker进程的通信" class="headerlink" title="master进程与worker进程的通信"></a>master进程与worker进程的通信</h3></li><li>fpm_scoreboard_proc_s在共享内存上，master通过这种方式获取worker的运营信息。</li><li>进程检查定时器：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fpm_event_loop</span><span class="params">(<span class="keyword">int</span> err)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="comment">/* add timers */</span></span><br><span class="line">    <span class="keyword">if</span> (fpm_globals.heartbeat &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        fpm_pctl_heartbeat(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">        fpm_pctl_perform_idle_server_maintenance_heartbeat(<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><p>fork完worker进城后，master进程会进入fpm_event_loop，其中fpm_pctl_perform_idle_server_maintenance_heartbeat定期检查worker进程数，并根据不同策略”kill“或“fork” worker进程。</p><h3 id="worker进程"><a href="#worker进程" class="headerlink" title="worker进程"></a>worker进程</h3><ul><li>调用fpm_request_info、php_request_startup获取请求内容及注册全局变量($_GET、$_POST、$_SERVER、$_ENV、$_FILES)；</li><li>根据请求信息调用php_fopen_primary_script访问脚本文件；</li><li>交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。<br>-执行php_request_shutdown函数。回调register_shutdown_function注册的函数及__destruct<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><a href="http://blog.csdn.net/Mijar2016/article/details/53414402" target="_blank" rel="noopener">http://blog.csdn.net/Mijar2016/article/details/53414402</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
