<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[奇怪的循环变量]]></title>
    <url>%2F2018%2F05%2F09%2F%E5%A5%87%E6%80%AA%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[php中循环引出的问题 问题描述有问题如下：12345678910&lt;?php$arr = [1,2,3];foreach ($arr as &amp;$v)&#123;&#125;foreach ($arr as $v)&#123; &#125;print_r($arr); 结果输出了：123456Array( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 2) 分析这里的v在第一次循环结束时并没有释放，循环结束后v依然指向arr的最后一个元素，而不是第一个元素。且由于是引用赋值，改变v的值是可以影响arr数组的，为之后的”bug”埋下了伏笔。换句话说，代码等价于:12345678910&lt;?php$arr = [1,2,3];foreach ($arr as &amp;$v)&#123;&#125;foreach ($arr as &amp;$v)&#123; &#125;print_r($arr); 第二次循环开始了，循环时会依次把遍历中的数组元素赋给v,注意这里v依然指向数组的最后一个元素，三次赋值的结果如下： $v&lt;-1,arr开始为[1,2,3]，赋值后arr为[1,2,1] $v&lt;-2,arr开始为[1,2,1]，赋值后arr为[1,2,2] $v&lt;-2,arr开始为[1,2,2]，赋值后arr为[1,2,2] 根本原因php中没有把循环看作一个独立的空间，在循环过程中新声明的变量就是全局变量，循环结束后变量并没有被释放。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识php-fpm]]></title>
    <url>%2F2018%2F03%2F28%2F%E5%88%9D%E8%AF%86php-fpm%2F</url>
    <content type="text"><![CDATA[一次完整的网络请求客户端发起请求时，php并不是像Golang那样实现http网络库，而是实现CGI协议，与web服务器配合实现了HTTP的处理。web服务处理HTTP请求，然后将解析结果再通过CGI协议转给底层解释器处理。 名词解释CGICGI全称是“公共网关接口”(Common Gateway Interface)，HTTP服务器与你的或其它机器上的程序进行“交谈”的一种工具，其程序须运行在网络服务器上。CGI的好处是完全独立于任何服务器，仅仅是做为中间分子。提供接口给服务器和php，但是CGI有个蛋疼的地方，就是每一次web请求都会有启动和退出过程，也就是最为人诟病的fork-and-execute模式，这样一在大规模并发下，就死翘翘了。 FastCGIFastCGI像是一个常驻(long-live)型的CGI，它可以一直执行着，只要激活后，不会每次都要花费时间去fork一次。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。Fastcgi会先启一个master，解析配置文件，初始化执行环境，然后再启动多个worker。当请求过来时，master会传递给一个worker，然后立即可以接受下一个请求。这样就避免了重复的劳动，效率自然是高。而且当worker不够用时，master可以根据配置预先启动几个worker等着；当然空闲worker太多时，也会停掉一些，这样就提高了性能，也节约了资源。这就是fastcgi的对进程的管理。 PHP-CGIPHP 对 Web Server 提供的 CGI 协议的接口程序。 PHP-FPMPHP 对 Web Server 提供的 FastCGI 协议的接口程序。 相关操作php-fpm在PHP 5.3.2以后的版本不支持以前的php-fpm (start|restart|stop|reload) 1234service php-fpm startservice php-fpm stopservice php-fpm restartservice php-fpm reload 基本实现FPM同时监听多个端口，每个端口对应一个worker pool，每个pool下对应多个worker 进程。但这些归属不同pool的woker进程仍然由一个master进程管理。示意图如下 什么是worker pool?123456789101112131415161718192021struct fpm_worker_pool_s &#123; struct fpm_worker_pool_s *next; /*下一个woker pool指针*/ struct fpm_worker_pool_config_s *config; /*php-fpm.conf相关*/ char *user, *home; /* for setting env USER and HOME */ enum fpm_address_domain listen_address_domain; int listening_socket; int set_uid, set_gid; /* config uid and gid */ int socket_uid, socket_gid, socket_mode; /* runtime */ struct fpm_child_s *children; int running_children; int idle_spawn_rate; int warn_max_children; struct fpm_scoreboard_s *scoreboard; /*记录worker进程运行信息的结构，记录FPM所有worker进程的统计信息*/ int log_fd; char **limit_extensions; /* for ondemand PM */ struct fpm_event_s *ondemand_event; int socket_event_set;&#125;; pool下的每个worker进程分配一个fpm_scoreboard_proc_s的结构，这些结构的地址保存在fpm_scoreboard_s-&gt;procs数组中。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct fpm_scoreboard_s &#123; union &#123; atomic_t lock; char dummy[16]; &#125;;//锁状态 char pool[32];//实例名称 例如：[www] int pm; //PM运行模式 这里有三种可选择：static、ondemand、dynamic time_t start_epoch; //开始时间 int idle;//procs的空闲数 int active;//procs的使用数 int active_max; //最大procs使用数 unsigned long int requests; unsigned int max_children_reached; //到达最大进程数限制的次数 int lq; //当前listen queue的请求数(accept操作，可以过tcpi_unacked或getsocketopt获取) int lq_max;//listen queue大小 unsigned int lq_len; unsigned int nprocs; //procs总数 int free_proc; //从procs列表遍历下一个空闲对象的开始下标 struct fpm_scoreboard_proc_s *procs[]; //列表&#125;;struct fpm_scoreboard_proc_s &#123; union &#123; atomic_t lock; char dummy[16]; &#125;;//锁状态 int used; //使用标识 0=未使用 1=正在使用 time_t start_epoch; //使用开始时间 pid_t pid; //进程id unsigned long requests; //处理请求次数 enum fpm_request_stage_e request_stage; //处理请求阶段 struct timeval accepted; //accept请求时间 struct timeval duration; //脚本总执行时间 time_t accepted_epoch;//accept请求时间戳(秒) struct timeval tv; //活跃时间 char request_uri[128]; //请求路径 char query_string[512]; //请求参数 char request_method[16]; //请求方式 size_t content_length; //请求内容长度 /* used with POST only */ char script_filename[256];//脚本名称 char auth_user[32];#ifdef HAVE_TIMES struct tms cpu_accepted; struct timeval cpu_duration; struct tms last_request_cpu; struct timeval last_request_cpu_duration;#endif size_t memory;//脚本占用的内存大小&#125;; 三种进程管理方式 static : 静态模式，启动时分配固定的worker进程。 ondemand: 按需分配，当收到用户请求时fork worker进程。 dynamic: 动态模式，启动时分配固定的进程。伴随着请求数增加，在设定的浮动范围调整worker进程。master进程与worker进程的通信 fpm_scoreboard_proc_s在共享内存上，master通过这种方式获取worker的运营信息。 进程检查定时器：1234567891011121314 void fpm_event_loop(int err) /* &#123;&#123;&#123; */&#123;... /* add timers */ if (fpm_globals.heartbeat &gt; 0) &#123; fpm_pctl_heartbeat(NULL, 0, NULL); &#125; if (!err) &#123; fpm_pctl_perform_idle_server_maintenance_heartbeat(NULL, 0, NULL); ... &#125;... &#125; fork完worker进城后，master进程会进入fpm_event_loop，其中fpm_pctl_perform_idle_server_maintenance_heartbeat定期检查worker进程数，并根据不同策略”kill“或“fork” worker进程。 worker进程 调用fpm_request_info、php_request_startup获取请求内容及注册全局变量($_GET、$_POST、$_SERVER、$_ENV、$_FILES)； 根据请求信息调用php_fopen_primary_script访问脚本文件； 交给php_execute_script执行。php_execute_script内部调用zend_execute_scripts方法将脚本交给zend引擎处理。-执行php_request_shutdown函数。回调register_shutdown_function注册的函数及__destruct参考资料http://blog.csdn.net/Mijar2016/article/details/53414402]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>技术</tag>
      </tags>
  </entry>
</search>
